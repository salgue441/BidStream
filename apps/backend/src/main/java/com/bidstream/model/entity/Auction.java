package com.bidstream.model.entity;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

/**
 * Auction entity representing individual auctions in the BidStream
 * platform. Contains auction details, timing information, pricing
 * data, and relationships to other entities like users and categories.
 */
@Entity
@Table(name = "auctions")
public class Auction {
  /**
   * Maximum allowed length for auction title (200 characters).
   * Used in {@code @Size} validation and as a column length
   * for title field.
   */
  public static final int MAX_TITLE_LENGTH = 200;

  /**
   * Maximum allowed length for auction description (200 characters).
   * Used as column length for description field.
   */
  public static final int MAX_DESCRIPTION_LENGTH = 2000;

  /**
   * Maximum allowed length for auction category (100 characters).
   * Used as column length for category field.
   */
  public static final int MAX_CATEGORY_LENGTH = 100;

  /**
   * Maximum allowed length for auction condition (50 characters).
   * Used as column length for condition field.
   */
  public static final int MAX_CONDITION_LENGTH = 50;

  /**
   * Maximum allowed length for auction location (200 characters).
   * Used as column length for location field.
   */
  public static final int MAX_LOCATION_LENGTH = 200;

  /**
   * Minimum decimal value for monetary amounts.
   * Used in validation for starting price, reserve price, and
   * buy now price.
   */
  public static final String MIN_PRICE_VALUE = "0.01";

  /**
   * Scale for decimal precision in moneteray calculations.
   * Used for BigDecimal price fields to ensure proper precision.
   */
  public static final int PRICE_SCALE = 2;

  /**
   * Precision for decimal precision.
   */
  public static final int PRICE_PRECISION = 19;

  /**
   * Maximum allowed length for auction status name (20 characters).
   */
  public static final int MAX_AUCTION_STATUS_LENGTH = 20;

  /**
   * Unique identifier for the auction.
   * Automatically generated by JPA.
   *
   * @see jakarta.persistence.Id
   * @see jakarta.persistence.GeneratatedValue
   */
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private UUID id;

  /**
   * Auction title. Must be non-blank and within length limits.
   *
   * @see #MAX_CATEGORY_LENGTH
   * @see jakarta.persistence.Column
   * @see jakarta.validation.constraints.NotBlank
   * @see jakarta.validation.constraints.Size
   */
  @Column(nullable = false, length = MAX_TITLE_LENGTH)
  @NotBlank(message = "Auction title is required")
  @Size(max = MAX_TITLE_LENGTH,
        message = "Title cannot exceed "
          + MAX_TITLE_LENGTH + " chars")
  private String title;

  /**
   * Detailed description of the auction item.
   * Optional filed with maximum length restriction.
   *
   * @see #MAX_DESCRIPTION_LENGTH
   * @see jakarta.persistence.Column
   */
  @Column(length = MAX_DESCRIPTION_LENGTH, columnDefinition = "TEXT")
  @Size(max = MAX_DESCRIPTION_LENGTH,
      message = "Description cannot exceed "
        + MAX_DESCRIPTION_LENGTH + " characters")
  private String description;

  /**
   * Item category for classification and filtering.
   * Used for organizing auctions by type.
   *
   * @see #MAX_CATEGORY_LENGTH
   * @see jakarta.persistence.Column
   * @see jakarta.validation.constraints.NotBlank
   */
  @Column(nullable = false, length = MAX_CATEGORY_LENGTH)
  @NotBlank(message = "Category is required")
  private String category;

  /**
   * Physical condition of the auction item.
   * Examples: "New", "Like New", "Good", "Fair", "Poor"
   *
   * @see #MAX_CONDITION_LENGTH
   * @see jakarta.persistence.Column
   */
  @Column(name = "item_condition", length = MAX_CONDITION_LENGTH)
  private String condition;

  /**
   * Geographic location of the item.
   * Used for shipping calculations and local pickup options.
   *
   * @see #MAX_LOCATION_LENGTH
   * @see jakarta.persistence.Column
   */
  @Column(length = MAX_LOCATION_LENGTH)
  private String location;

  /**
   * Starting bid amount for the auction.
   * Must be a positive decimal value with proper precision.
   *
   * @see #MIN_PRICE_VALUE
   * @see #PRICE_SCALE
   * @see jakarta.persistence.Column
   * @see jakarta.validation.constraints.NotNull
   * @see jakarta.validation.constraints.DecimalMin
   */
  @Column(name = "starting_price",
      nullable = false,
          precision = PRICE_PRECISION, scale = PRICE_SCALE)
  @NotNull(message = "Starting price is required")
  @DecimalMin(value = MIN_PRICE_VALUE,
       message = "Starting price must be at least $0.01")
  private BigDecimal startingPrice;

  /**
   * Current highest bid amount.
   * Automatically updated when new bids are placed.
   *
   * @see #PRICE_SCALE
   * @see jakarta.persistence.Column
   */
  @Column(name = "current_price",
      precision = PRICE_PRECISION, scale = PRICE_SCALE)
  private BigDecimal currentPrice;

  /**
   * Reserve price - minimum amount for successful sale.
   * If not met, auction may not complete even with bids.
   *
   * @see #PRICE_SCALE
   * @see jakarta.persistence.Column
   */
  @Column(name = "reserve_price",
      precision = PRICE_PRECISION, scale = PRICE_SCALE)
  private BigDecimal reservePrice;

  /**
   * Buy Now price for immediate purchase.
   * Allows buyers to end auction early at fixed price.
   *
   * @see #PRICE_SCALE
   * @see jakarta.persistence.Column
   */
  @Column(name = "buy_now_price",
      precision = PRICE_PRECISION, scale = PRICE_SCALE)
  private BigDecimal buyNowPrice;

  /**
   * Total number of bids placed on this auction.
   * Updated automatically when bids are placed.
   */
  @Column(name = "bid_count")
  private Integer bidCount = 0;

  /**
   * Number of users watching this auction.
   * Used for popularity tracking and notifications.
   */
  @Column(name = "watch_count")
  private Integer watchCount = 0;

  /**
   * Number of times this auction has been viewed.
   * Used for analytics and trending calculations.
   */
  @Column(name = "view_count")
  private Integer viewCount = 0;

  /**
   * When the auction bidding starts.
   * Must be in the future when auction is created.
   *
   * @see jakarta.persistence.Column
   * @see jakarta.validation.constraints.NotNull
   * @see jakarta.validation.constraints.Future
   */
  @Column(name = "start_time", nullable = false)
  @NotNull(message = "Auction start time is required")
  @Future(message = "Auction start time must be in the future")
  private LocalDateTime startTime;

  /**
   * When the auction bidding ends.
   * Must be after start time.
   *
   * @see jakarta.persistence.Column
   * @see jakarta.validation.constraints.NotNull
   */
  @Column(name = "end_time", nullable = false)
  @NotNull(message = "Auction end time is required")
  private LocalDateTime endTime;

  /**
   * Current status of the auction.
   * Controls auction behavior and bidding availability.
   *
   * @see AuctionStatus
   * @see jakarta.persistence.Enumerated
   * @see jakarta.persistence.Column
   */
  @Enumerated(EnumType.STRING)
  @Column(nullable = false,
      length = MAX_AUCTION_STATUS_LENGTH)
  private AuctionStatus status = AuctionStatus.DRAFT;

  /**
   * Whether the auction is featured/promoted.
   * Featured auctions may receive priority placement.
   */
  @Column(name = "is_featured")
  private Boolean featured = false;

  /**
   * Whether the reserve price has been met.
   * Updated automatically based on current bidding.
   */
  @Column(name = "reserve_met")
  private Boolean reserveMet = false;

  /**
   * User who created this auction (seller).
   * Cannot be null - every auction must have an owner.
   *
   * @see User
   * @see jakarta.persistence.ManyToOne
   * @see jakarta.persistence.JoinColumn
   * @see jakarta.validation.constraints.NotNull
   */
  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "seller_id", nullable = false)
  @NotNull(message = "Seller is required")
  private User seller;

  /**
   * User with the current highest bid (winner if auction ended).
   * Null if no bids have been placed.
   *
   * @see User
   * @see jakarta.persistence.ManyToOne
   * @see jakarta.persistence.JoinColumn
   */
  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "highest_bidder_id")
  private User highestBidder;

  /**
   * Timestamp when auction was created.
   * Set automatically and cannot be updated.
   */
  @Column(name = "created_at", updatable = false)
  private LocalDateTime createdAt;

  /**
   * Timestamp when auction was last updated.
   * Automatically maintained by the system.
   */
  @Column(name = "updated_at")
  private LocalDateTime updatedAt;

  /**
   * Default constructor.
   */
  public Auction() {
  }

  /**
   * Constructor with required fields.
   *
   * @param newTitle        the auction title
   * @param newCategory     the item category
   * @param newStartingPrice the starting bid amount
   * @param newStartTime    when bidding starts
   * @param newEndTime      when bidding ends
   * @param newSeller       the auction creator
   */
  public Auction(final String newTitle, final String newCategory,
      final BigDecimal newStartingPrice, final LocalDateTime newStartTime,
      final LocalDateTime newEndTime, final User newSeller) {
    this.title = newTitle;
    this.category = newCategory;
    this.startingPrice = newStartingPrice;
    this.currentPrice = newStartingPrice;
    this.startTime = newStartTime;
    this.endTime = newEndTime;
    this.seller = newSeller;
  }

  /**
   * JPA lifecycle callback that executes before entity persistence (insert).
   * Automatically sets the creation and update timestamps to current time.
   * Also initializes currentPrice to startingPrice if not set.
   *
   * @see jakarta.persistence.PrePersist
   * @see #createdAt
   * @see #updatedAt
   */
  @PrePersist
  protected void onCreate() {
    this.createdAt = LocalDateTime.now();
    this.updatedAt = LocalDateTime.now();

    if (this.currentPrice == null) {
      this.currentPrice = this.startingPrice;
    }
  }

  /**
   * JPA lifecycle callback that executes before entity update.
   * Automatically updates the modification timestamp to current time.
   *
   * @see jakarta.persistence.PreUpdate
   * @see #updatedAt
   */
  @PreUpdate
  protected void onUpdate() {
    this.updatedAt = LocalDateTime.now();
  }

  /**
   * Checks if the auction is currently active for bidding.
   *
   * @return true if auction is active and within time window
   */
  public boolean isActive() {
    LocalDateTime now = LocalDateTime.now();
    return status == AuctionStatus.ACTIVE
        && now.isAfter(startTime)
        && now.isBefore(endTime);
  }

  /**
   * Checks if the auction has ended.
   *
   * @return true if auction end time has passed
   */
  public boolean hasEnded() {
    return LocalDateTime.now().isAfter(endTime);
  }

  /**
   * Checks if the auction allows Buy Now purchases.
   *
   * @return true if Buy Now price is set and auction is active
   */
  public boolean hasBuyNowOption() {
    return buyNowPrice != null && isActive();
  }

  /**
   * Gets the time remaining in the auction.
   *
   * @return duration until auction ends, or null if already ended
   */
  public java.time.Duration getTimeRemaining() {
    LocalDateTime now = LocalDateTime.now();
    if (now.isAfter(endTime)) {
      return null;
    }

    return java.time.Duration.between(now, endTime);
  }

  // Getters and setters
  /**
   * Gets the unique identifier for this auction.
   *
   * @return the auction's UUID
   */
  public UUID getId() {
    return id;
  }

  /**
   * Sets the unique identifier for this auction.
   *
   * @param newId the UUID to set
   */
  public void setId(final UUID newId) {
    this.id = newId;
  }

  /**
   * Gets the auction title.
   *
   * @return the auction title (never null for valid auctions)
   */
  public String getTitle() {
    return title;
  }

  /**
   * Sets the auction title.
   *
   * @param newTitle the title to set (must not be blank)
   */
  public void setTitle(final String newTitle) {
    this.title = newTitle;
  }

  /**
   * Gets the auction description.
   *
   * @return the description (may be null)
   */
  public String getDescription() {
    return description;
  }

  /**
   * Sets the auction description.
   *
   * @param newDescription the description to set
   */
  public void setDescription(final String newDescription) {
    this.description = newDescription;
  }

  /**
   * Gets the item category.
   *
   * @return the category (never null for valid auctions)
   */
  public String getCategory() {
    return category;
  }

  /**
   * Sets the item category.
   *
   * @param newCategory the category to set (must not be blank)
   */
  public void setCategory(final String newCategory) {
    this.category = newCategory;
  }

  /**
   * Gets the item condition.
   *
   * @return the condition description (may be null)
   */
  public String getCondition() {
    return condition;
  }

  /**
   * Sets the item condition.
   *
   * @param newCondition the condition to set
   */
  public void setCondition(final String newCondition) {
    this.condition = newCondition;
  }

  /**
   * Gets the item location.
   *
   * @return the location (may be null)
   */
  public String getLocation() {
    return location;
  }

  /**
   * Sets the item location.
   *
   * @param newLocation the location to set
   */
  public void setLocation(final String newLocation) {
    this.location = newLocation;
  }

  /**
   * Gets the starting price.
   *
   * @return the starting bid amount (never null for valid auctions)
   */
  public BigDecimal getStartingPrice() {
    return startingPrice;
  }

  /**
   * Sets the starting price.
   *
   * @param newStartingPrice the starting price to set (must be positive)
   */
  public void setStartingPrice(final BigDecimal newStartingPrice) {
    this.startingPrice = newStartingPrice;
  }

  /**
   * Gets the current highest bid.
   *
   * @return the current price (never null, defaults to starting price)
   */
  public BigDecimal getCurrentPrice() {
    return currentPrice;
  }

  /**
   * Sets the current highest bid.
   *
   * @param newCurrentPrice the current price to set
   */
  public void setCurrentPrice(final BigDecimal newCurrentPrice) {
    this.currentPrice = newCurrentPrice;
  }

  /**
   * Gets the reserve price.
   *
   * @return the reserve price (may be null if no reserve)
   */
  public BigDecimal getReservePrice() {
    return reservePrice;
  }

  /**
   * Sets the reserve price.
   *
   * @param newReservePrice the reserve price to set
   */
  public void setReservePrice(final BigDecimal newReservePrice) {
    this.reservePrice = newReservePrice;
  }

  /**
   * Gets the Buy Now price.
   *
   * @return the Buy Now price (may be null if not available)
   */
  public BigDecimal getBuyNowPrice() {
    return buyNowPrice;
  }

  /**
   * Sets the Buy Now price.
   *
   * @param newBuyNowPrice the Buy Now price to set
   */
  public void setBuyNowPrice(final BigDecimal newBuyNowPrice) {
    this.buyNowPrice = newBuyNowPrice;
  }

  /**
   * Gets the total number of bids.
   *
   * @return the bid count
   */
  public Integer getBidCount() {
    return bidCount;
  }

  /**
   * Sets the total number of bids.
   *
   * @param newBidCount the bid count to set
   */
  public void setBidCount(final Integer newBidCount) {
    this.bidCount = newBidCount;
  }

  /**
   * Gets the number of watchers.
   *
   * @return the watch count
   */
  public Integer getWatchCount() {
    return watchCount;
  }

  /**
   * Sets the number of watchers.
   *
   * @param newWatchCount the watch count to set
   */
  public void setWatchCount(final Integer newWatchCount) {
    this.watchCount = newWatchCount;
  }

  /**
   * Gets the view count.
   *
   * @return the number of views
   */
  public Integer getViewCount() {
    return viewCount;
  }

  /**
   * Sets the view count.
   *
   * @param newViewCount the view count to set
   */
  public void setViewCount(final Integer newViewCount) {
    this.viewCount = newViewCount;
  }

  /**
   * Gets the auction start time.
   *
   * @return when bidding starts (never null for valid auctions)
   */
  public LocalDateTime getStartTime() {
    return startTime;
  }

  /**
   * Sets the auction start time.
   *
   * @param newStartTime when bidding should start (must be in future)
   */
  public void setStartTime(final LocalDateTime newStartTime) {
    this.startTime = newStartTime;
  }

  /**
   * Gets the auction end time.
   *
   * @return when bidding ends (never null for valid auctions)
   */
  public LocalDateTime getEndTime() {
    return endTime;
  }

  /**
   * Sets the auction end time.
   *
   * @param newEndTime when bidding should end (must be after start time)
   */
  public void setEndTime(final LocalDateTime newEndTime) {
    this.endTime = newEndTime;
  }

  /**
   * Gets the auction status.
   *
   * @return the current status
   */
  public AuctionStatus getStatus() {
    return status;
  }

  /**
   * Sets the auction status.
   *
   * @param newStatus the status to set
   */
  public void setStatus(final AuctionStatus newStatus) {
    this.status = newStatus;
  }

  /**
   * Checks if the auction is featured.
   *
   * @return true if featured
   */
  public Boolean isFeatured() {
    return featured;
  }

  /**
   * Sets the featured status.
   *
   * @param isFeatured true to feature the auction
   */
  public void setFeatured(final Boolean isFeatured) {
    this.featured = isFeatured;
  }

  /**
   * Checks if reserve price has been met.
   *
   * @return true if reserve is met
   */
  public Boolean isReserveMet() {
    return reserveMet;
  }

  /**
   * Sets the reserve met status.
   *
   * @param isReserveMet true if reserve is met
   */
  public void setReserveMet(final Boolean isReserveMet) {
    this.reserveMet = isReserveMet;
  }

  /**
   * Gets the seller (auction creator).
   *
   * @return the seller user (never null for valid auctions)
   */
  public User getSeller() {
    return seller;
  }

  /**
   * Sets the seller (auction creator).
   *
   * @param newSeller the seller to set (must not be null)
   */
  public void setSeller(final User newSeller) {
    this.seller = newSeller;
  }

  /**
   * Gets the highest bidder.
   *
   * @return the highest bidder (null if no bids placed)
   */
  public User getHighestBidder() {
    return highestBidder;
  }

  /**
   * Sets the highest bidder.
   *
   * @param newHighestBidder the highest bidder to set
   */
  public void setHighestBidder(final User newHighestBidder) {
    this.highestBidder = newHighestBidder;
  }

  /**
   * Gets the creation timestamp.
   *
   * @return when the auction was created
   */
  public LocalDateTime getCreatedAt() {
    return createdAt;
  }

  /**
   * Gets the last update timestamp.
   *
   * @return when the auction was last modified
   */
  public LocalDateTime getUpdatedAt() {
    return updatedAt;
  }

  // Class overloads
  /**
   * Returns a string representation of the auction.
   *
   * @return string containing key auction details
   */
  @Override
  public String toString() {
    return "Auction{"
        + "id=" + id
        + ", title='" + title + '\''
        + ", category='" + category + '\''
        + ", currentPrice=" + currentPrice
        + ", status=" + status
        + '}';
  }
}

